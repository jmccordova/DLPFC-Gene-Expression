model.rf <- randomForest(x = trainset.multinomial[, colnames(trainset.multinomial) != "diagnosis"],
y = trainset.multinomial$diagnosis,
ntree = 501,
mtry = 100
)
# Part 4.2: Create a function for each ML
perform_learning <- function(method, trainset, testset,
svm.kernel = NULL,
svm.cost = NULL,
rf.ntree = NULL,
rf.mtry = NULL,
export.filename = NULL,
tune = FALSE) {
if (method == "NB") {
# Part 4.1: Naive Bayes
set.seed(100)
model.nb <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "naive_bayes",
trControl = trainControl(method='cv', number=10)
)
pred.model.nb <- predict(model.nb, newdata = testset[, colnames(trainset) != "diagnosis"])
confMatrix.model.nb <- confusionMatrix(pred.model.nb, testset$diagnosis)
var.model.nb <- varImp(model.nb, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "KNN") {
# Part 4.2: K Nearest Neighbors
set.seed(100)
trControl.knn <- trainControl(method='repeatedcv', number = 3, allowParallel = TRUE)
trainset.preprocessed <- preProcess(trainset[, colnames(trainset) != "diagnosis"])
model.knn <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "knn",
trControl = trControl.knn,
tuneLength = 20
)
pred.model.knn <- predict(model.knn, newdata = testset)
confMatrix.model.knn <- confusionMatrix(pred.model.knn, testset$diagnosis)
var.model.knn <- varImp(model.knn, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "DT") {
# Part 4.3: Decision Tree
# Part 4.3.1: Using rpart
model.dt <- rpart(formula = diagnosis ~ .,
data = trainset,
method = "class",
control = rpart.control(minsplit=2, minbucket = 1, cp = 0.001)
)
var.model.dt<- varImp(model.dt, useModel = TRUE, nonpara = TRUE, scale = TRUE)
rpart.plot(model.dt)
pdf(export.filename)
prp(model.dt, extra=104)
dev.off()
# Part 4.3.2: Using train
## 10-fold CV
## repeated ten times
trControl.dt <- trainControl(
method = "repeatedcv",
number = 5,
repeats = 10)
model.dt <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "rpart2",
trControl = trControl.dt
)
pred.model.dt <- predict(model.dt, newdata = testset)
confMatrix.model.dt <- confusionMatrix(pred.model.dt, testset$diagnosis)
} else if (method == "SVM") {
# Part 4.4: SVM
# For SVM and random forest, cut the dataset to 10% of the dataset to make processing quicker
#trainset.cut <- trainset[sample(x = 1:nrow(trainset), size = nrow(trainset) * .10, replace = TRUE), colnames(trainset)]
#trainset.cut <- upSample(x = trainset.cut[, colnames(trainset.cut) %ni% "ADDEPEV3"], yname = "ADDEPEV3", y = trainset.cut$ADDEPEV3)
if (tune) {
kernels <- c("rbfdot", "polydot", "tanhdot", "vanilladot", "laplacedot", "besseldot", "anovadot", "splinedot")
costs <- c(0.001, 0.01, 0.1, 1, 5, 10, 100)
} else {
kernels <- c(svm.kernel)
costs <- c(svm.cost)
}
for (kernel in kernels) {
for (cost in costs) {
print(paste(kernel," @ ", cost))
model.svm <- rminer::fit(diagnosis ~ .,
data = trainset,
model = "svm",
kernel = kernel,
kpar = "automatic",
C = cost,
task = "class"
)
pred.model.svm <- predict(model.svm, newdata = testset)
confMatrix.model.svm <- confusionMatrix(pred.model.svm, testset$diagnosis)
print(confMatrix.model.svm)
var.model.svm <- Importance(model.svm, data = trainset)
}
}
} else if (method == "LOG") {
model.logit <- multinom(diagnosis ~ .,
data = trainset)
pred.model.logit <- predict(model.logit, newdata = testset[, colnames(testset) != "diagnosis"], type = "class")
confMatrix.model.logit <- confusionMatrix(pred.model.logit, testset$diagnosis)
var.model.logit <- varImp(model.logit, useModel = TRUE, nonpara = TRUE, scale = TRUE)
summary(model.logit)
View(cbind("coeff" = coef(model.logit), "odds ratio" = (exp(coef(model.logit)) - 1) * 100)) # Odds ratio
} else if (method == "DA") {
# Part 4.6: Discriminant Analysis
} else if (method == "RF") {
# Part 4.7: Random Forest
set.seed(100)
if (tune) {
mtries <- sort.int(sample(ncol(trainset)-1, 5))
ntrees <- c(201, 501, 1501, 2501, 3501)
} else {
mtries <- c(rf.mtry)
ntrees <- c(rf.ntree)
}
for(ntree in ntrees) {
for(mtry in mtries) {
model.rf <- randomForest(x = trainset[, colnames(trainset.multinomial) != "diagnosis"],
y = trainset$diagnosis,
ntree = ntree,
mtry = mtry
)
pred.model.rf <- predict(model.rf, newdata = testset)
confMatrix.model.rf <- confusionMatrix(pred.model.rf, testset$diagnosis)
}
}
} else {
print('No such methodology')
}
}
pred.model.rf <- predict(model.rf, newdata = testset)
pred.model.rf <- predict(model.rf, newdata = testset.multinomial)
confMatrix.model.rf <- confusionMatrix(pred.model.rf, testset$diagnosis)
confMatrix.model.rf <- confusionMatrix(pred.model.rf, testset.multinomial$diagnosis)
perform_learning("RF", trainset.multinomial[, features.selected], testset.multinomial[, features.selected], tune = TRUE)
# Part 4.2: Create a function for each ML
perform_learning <- function(method, trainset, testset,
svm.kernel = NULL,
svm.cost = NULL,
rf.ntree = NULL,
rf.mtry = NULL,
export.filename = NULL,
tune = FALSE) {
if (method == "NB") {
# Part 4.1: Naive Bayes
set.seed(100)
model.nb <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "naive_bayes",
trControl = trainControl(method='cv', number=10)
)
pred.model.nb <- predict(model.nb, newdata = testset[, colnames(trainset) != "diagnosis"])
confMatrix.model.nb <- confusionMatrix(pred.model.nb, testset$diagnosis)
var.model.nb <- varImp(model.nb, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "KNN") {
# Part 4.2: K Nearest Neighbors
set.seed(100)
trControl.knn <- trainControl(method='repeatedcv', number = 3, allowParallel = TRUE)
trainset.preprocessed <- preProcess(trainset[, colnames(trainset) != "diagnosis"])
model.knn <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "knn",
trControl = trControl.knn,
tuneLength = 20
)
pred.model.knn <- predict(model.knn, newdata = testset)
confMatrix.model.knn <- confusionMatrix(pred.model.knn, testset$diagnosis)
var.model.knn <- varImp(model.knn, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "DT") {
# Part 4.3: Decision Tree
# Part 4.3.1: Using rpart
model.dt <- rpart(formula = diagnosis ~ .,
data = trainset,
method = "class",
control = rpart.control(minsplit=2, minbucket = 1, cp = 0.001)
)
var.model.dt<- varImp(model.dt, useModel = TRUE, nonpara = TRUE, scale = TRUE)
rpart.plot(model.dt)
pdf(export.filename)
prp(model.dt, extra=104)
dev.off()
# Part 4.3.2: Using train
## 10-fold CV
## repeated ten times
trControl.dt <- trainControl(
method = "repeatedcv",
number = 5,
repeats = 10)
model.dt <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "rpart2",
trControl = trControl.dt
)
pred.model.dt <- predict(model.dt, newdata = testset)
confMatrix.model.dt <- confusionMatrix(pred.model.dt, testset$diagnosis)
} else if (method == "SVM") {
# Part 4.4: SVM
# For SVM and random forest, cut the dataset to 10% of the dataset to make processing quicker
#trainset.cut <- trainset[sample(x = 1:nrow(trainset), size = nrow(trainset) * .10, replace = TRUE), colnames(trainset)]
#trainset.cut <- upSample(x = trainset.cut[, colnames(trainset.cut) %ni% "ADDEPEV3"], yname = "ADDEPEV3", y = trainset.cut$ADDEPEV3)
if (tune) {
kernels <- c("rbfdot", "polydot", "tanhdot", "vanilladot", "laplacedot", "besseldot", "anovadot", "splinedot")
costs <- c(0.001, 0.01, 0.1, 1, 5, 10, 100)
} else {
kernels <- c(svm.kernel)
costs <- c(svm.cost)
}
for (kernel in kernels) {
for (cost in costs) {
print(paste(kernel," @ ", cost))
model.svm <- rminer::fit(diagnosis ~ .,
data = trainset,
model = "svm",
kernel = kernel,
kpar = "automatic",
C = cost,
task = "class"
)
pred.model.svm <- predict(model.svm, newdata = testset)
confMatrix.model.svm <- confusionMatrix(pred.model.svm, testset$diagnosis)
print(confMatrix.model.svm)
var.model.svm <- Importance(model.svm, data = trainset)
}
}
} else if (method == "LOG") {
model.logit <- multinom(diagnosis ~ .,
data = trainset)
pred.model.logit <- predict(model.logit, newdata = testset[, colnames(testset) != "diagnosis"], type = "class")
confMatrix.model.logit <- confusionMatrix(pred.model.logit, testset$diagnosis)
var.model.logit <- varImp(model.logit, useModel = TRUE, nonpara = TRUE, scale = TRUE)
summary(model.logit)
View(cbind("coeff" = coef(model.logit), "odds ratio" = (exp(coef(model.logit)) - 1) * 100)) # Odds ratio
} else if (method == "DA") {
# Part 4.6: Discriminant Analysis
} else if (method == "RF") {
# Part 4.7: Random Forest
set.seed(100)
if (tune) {
mtries <- sort.int(sample(ncol(trainset)-1, 5))
ntrees <- c(201, 501, 1501, 2501, 3501)
} else {
mtries <- c(rf.mtry)
ntrees <- c(rf.ntree)
}
for(ntree in ntrees) {
for(mtry in mtries) {
model.rf <- randomForest(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
ntree = ntree,
mtry = mtry
)
pred.model.rf <- predict(model.rf, newdata = testset)
confMatrix.model.rf <- confusionMatrix(pred.model.rf, testset$diagnosis)
}
}
} else {
print('No such methodology')
}
}
# Part 4.2: Create a function for each ML
perform_learning <- function(method, trainset, testset,
svm.kernel = NULL,
svm.cost = NULL,
rf.ntree = NULL,
rf.mtry = NULL,
export.filename = NULL,
tune = FALSE) {
if (method == "NB") {
# Part 4.1: Naive Bayes
set.seed(100)
model.nb <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "naive_bayes",
trControl = trainControl(method='cv', number=10)
)
pred.model.nb <- predict(model.nb, newdata = testset[, colnames(trainset) != "diagnosis"])
confMatrix.model.nb <- confusionMatrix(pred.model.nb, testset$diagnosis)
var.model.nb <- varImp(model.nb, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "KNN") {
# Part 4.2: K Nearest Neighbors
set.seed(100)
trControl.knn <- trainControl(method='repeatedcv', number = 3, allowParallel = TRUE)
trainset.preprocessed <- preProcess(trainset[, colnames(trainset) != "diagnosis"])
model.knn <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "knn",
trControl = trControl.knn,
tuneLength = 20
)
pred.model.knn <- predict(model.knn, newdata = testset)
confMatrix.model.knn <- confusionMatrix(pred.model.knn, testset$diagnosis)
var.model.knn <- varImp(model.knn, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "DT") {
# Part 4.3: Decision Tree
# Part 4.3.1: Using rpart
model.dt <- rpart(formula = diagnosis ~ .,
data = trainset,
method = "class",
control = rpart.control(minsplit=2, minbucket = 1, cp = 0.001)
)
var.model.dt<- varImp(model.dt, useModel = TRUE, nonpara = TRUE, scale = TRUE)
rpart.plot(model.dt)
pdf(export.filename)
prp(model.dt, extra=104)
dev.off()
# Part 4.3.2: Using train
## 10-fold CV
## repeated ten times
trControl.dt <- trainControl(
method = "repeatedcv",
number = 5,
repeats = 10)
model.dt <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "rpart2",
trControl = trControl.dt
)
pred.model.dt <- predict(model.dt, newdata = testset)
confMatrix.model.dt <- confusionMatrix(pred.model.dt, testset$diagnosis)
} else if (method == "SVM") {
# Part 4.4: SVM
# For SVM and random forest, cut the dataset to 10% of the dataset to make processing quicker
#trainset.cut <- trainset[sample(x = 1:nrow(trainset), size = nrow(trainset) * .10, replace = TRUE), colnames(trainset)]
#trainset.cut <- upSample(x = trainset.cut[, colnames(trainset.cut) %ni% "ADDEPEV3"], yname = "ADDEPEV3", y = trainset.cut$ADDEPEV3)
if (tune) {
kernels <- c("rbfdot", "polydot", "tanhdot", "vanilladot", "laplacedot", "besseldot", "anovadot", "splinedot")
costs <- c(0.001, 0.01, 0.1, 1, 5, 10, 100)
} else {
kernels <- c(svm.kernel)
costs <- c(svm.cost)
}
for (kernel in kernels) {
for (cost in costs) {
print(paste(kernel," @ ", cost))
model.svm <- rminer::fit(diagnosis ~ .,
data = trainset,
model = "svm",
kernel = kernel,
kpar = "automatic",
C = cost,
task = "class"
)
pred.model.svm <- predict(model.svm, newdata = testset)
confMatrix.model.svm <- confusionMatrix(pred.model.svm, testset$diagnosis)
print(confMatrix.model.svm)
var.model.svm <- Importance(model.svm, data = trainset)
}
}
} else if (method == "LOG") {
model.logit <- multinom(diagnosis ~ .,
data = trainset)
pred.model.logit <- predict(model.logit, newdata = testset[, colnames(testset) != "diagnosis"], type = "class")
confMatrix.model.logit <- confusionMatrix(pred.model.logit, testset$diagnosis)
var.model.logit <- varImp(model.logit, useModel = TRUE, nonpara = TRUE, scale = TRUE)
summary(model.logit)
View(cbind("coeff" = coef(model.logit), "odds ratio" = (exp(coef(model.logit)) - 1) * 100)) # Odds ratio
} else if (method == "DA") {
# Part 4.6: Discriminant Analysis
} else if (method == "RF") {
# Part 4.7: Random Forest
set.seed(100)
if (tune) {
mtries <- sort.int(sample(ncol(trainset)-1, 5))
ntrees <- c(201, 501, 1501, 2501, 3501)
} else {
mtries <- c(rf.mtry)
ntrees <- c(rf.ntree)
}
for(ntree in ntrees) {
for(mtry in mtries) {
model.rf <- randomForest(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
ntree = ntree,
mtry = mtry
)
pred.model.rf <- predict(model.rf, newdata = testset)
confMatrix.model.rf <- confusionMatrix(pred.model.rf, testset$diagnosis)
}
}
} else {
print('No such methodology')
}
}
perform_learning("RF", trainset.multinomial[, features.selected], testset.multinomial[, features.selected], tune = TRUE)
perform_learning("RF", trainset.multinomial[, features.selected], testset.multinomial[, features.selected], tune = TRUE)
# Part 4.2: Create a function for each ML
perform_learning <- function(method, trainset, testset,
svm.kernel = NULL,
svm.cost = NULL,
rf.ntree = NULL,
rf.mtry = NULL,
export.filename = NULL,
tune = FALSE) {
if (method == "NB") {
# Part 4.1: Naive Bayes
set.seed(100)
model.nb <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "naive_bayes",
trControl = trainControl(method='cv', number=10)
)
pred.model.nb <- predict(model.nb, newdata = testset[, colnames(trainset) != "diagnosis"])
confMatrix.model.nb <- confusionMatrix(pred.model.nb, testset$diagnosis)
var.model.nb <- varImp(model.nb, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "KNN") {
# Part 4.2: K Nearest Neighbors
set.seed(100)
trControl.knn <- trainControl(method='repeatedcv', number = 3, allowParallel = TRUE)
trainset.preprocessed <- preProcess(trainset[, colnames(trainset) != "diagnosis"])
model.knn <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "knn",
trControl = trControl.knn,
tuneLength = 20
)
pred.model.knn <- predict(model.knn, newdata = testset)
confMatrix.model.knn <- confusionMatrix(pred.model.knn, testset$diagnosis)
var.model.knn <- varImp(model.knn, useModel = TRUE, nonpara = TRUE, scale = TRUE)
} else if (method == "DT") {
# Part 4.3: Decision Tree
# Part 4.3.1: Using rpart
model.dt <- rpart(formula = diagnosis ~ .,
data = trainset,
method = "class",
control = rpart.control(minsplit=2, minbucket = 1, cp = 0.001)
)
var.model.dt<- varImp(model.dt, useModel = TRUE, nonpara = TRUE, scale = TRUE)
rpart.plot(model.dt)
pdf(export.filename)
prp(model.dt, extra=104)
dev.off()
# Part 4.3.2: Using train
## 10-fold CV
## repeated ten times
trControl.dt <- trainControl(
method = "repeatedcv",
number = 5,
repeats = 10)
model.dt <- train(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
method = "rpart2",
trControl = trControl.dt
)
pred.model.dt <- predict(model.dt, newdata = testset)
confMatrix.model.dt <- confusionMatrix(pred.model.dt, testset$diagnosis)
} else if (method == "SVM") {
# Part 4.4: SVM
# For SVM and random forest, cut the dataset to 10% of the dataset to make processing quicker
#trainset.cut <- trainset[sample(x = 1:nrow(trainset), size = nrow(trainset) * .10, replace = TRUE), colnames(trainset)]
#trainset.cut <- upSample(x = trainset.cut[, colnames(trainset.cut) %ni% "ADDEPEV3"], yname = "ADDEPEV3", y = trainset.cut$ADDEPEV3)
if (tune) {
kernels <- c("rbfdot", "polydot", "tanhdot", "vanilladot", "laplacedot", "besseldot", "anovadot", "splinedot")
costs <- c(0.001, 0.01, 0.1, 1, 5, 10, 100)
} else {
kernels <- c(svm.kernel)
costs <- c(svm.cost)
}
for (kernel in kernels) {
for (cost in costs) {
print(paste(kernel," @ ", cost))
model.svm <- rminer::fit(diagnosis ~ .,
data = trainset,
model = "svm",
kernel = kernel,
kpar = "automatic",
C = cost,
task = "class"
)
pred.model.svm <- predict(model.svm, newdata = testset)
confMatrix.model.svm <- confusionMatrix(pred.model.svm, testset$diagnosis)
print(confMatrix.model.svm)
var.model.svm <- Importance(model.svm, data = trainset)
}
}
} else if (method == "LOG") {
model.logit <- multinom(diagnosis ~ .,
data = trainset)
pred.model.logit <- predict(model.logit, newdata = testset[, colnames(testset) != "diagnosis"], type = "class")
confMatrix.model.logit <- confusionMatrix(pred.model.logit, testset$diagnosis)
var.model.logit <- varImp(model.logit, useModel = TRUE, nonpara = TRUE, scale = TRUE)
summary(model.logit)
View(cbind("coeff" = coef(model.logit), "odds ratio" = (exp(coef(model.logit)) - 1) * 100)) # Odds ratio
} else if (method == "DA") {
# Part 4.6: Discriminant Analysis
} else if (method == "RF") {
# Part 4.7: Random Forest
set.seed(100)
if (tune) {
mtries <- sort.int(sample(ncol(trainset)-1, 5))
ntrees <- c(201, 501, 1501, 2501, 3501)
} else {
mtries <- c(rf.mtry)
ntrees <- c(rf.ntree)
}
for(ntree in ntrees) {
for(mtry in mtries) {
print(paste(ntree," and ", mtry))
model.rf <- randomForest(x = trainset[, colnames(trainset) != "diagnosis"],
y = trainset$diagnosis,
ntree = ntree,
mtry = mtry
)
pred.model.rf <- predict(model.rf, newdata = testset)
confMatrix.model.rf <- confusionMatrix(pred.model.rf, testset$diagnosis)
print(confMatrix.model.rf)
var.model.rf <- varImp(model.rf, useModel = TRUE, nonpara = TRUE, scale = TRUE)
}
}
} else {
print('No such methodology')
}
}
perform_learning("RF", trainset.multinomial[, features.selected], testset.multinomial[, features.selected], tune = TRUE)
