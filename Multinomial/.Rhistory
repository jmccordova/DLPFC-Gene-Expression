strsplit("Sam sq", split = "_")
colnames.e[i]
colnames.e
# Part 2.8: Rename the columns of exprs(e)
colnames.e <- colnames(exprs(e))
colnames.e
strsplit(colnames.e[i], split = "_")[1]
strsplit(colnames.e[i], split = "_")
strsplit(colnames.e[i], split = "_")[[1]]
strsplit(colnames.e[i], split = "_")[[1]][1]
# Part 2.8: Rename the columns of exprs(e)
colnames.e <- colnames(exprs(e))
for (i in 1:length(colnames.e)) {
colnames.e[i] <- strsplit(colnames.e[i], split = "_")[[1]][1]
}
colnames(exprs(e)) <- colnames.e
# Part 2.8: Rename the columns of exprs(e)
colnames.e <- colnames(exprs(e))
for (i in 1:length(colnames.e)) {
colnames.e[i] <- strsplit(colnames.e[i], split = "_")[[1]][1]
}
colnames.e
colnames(exprs(e))
unique(colnames.e)
colnames(e)
# Part 2.8: Rename the columns of exprs(e)
colnames.e <- colnames(e)
for (i in 1:length(colnames.e)) {
colnames.e[i] <- strsplit(colnames.e[i], split = "_")[[1]][1]
}
colnames(e) <- colnames.e
data <- as.data.frame(exprs(e))
View(data)
# Part 2.8: View data as box and whiskers
boxplot(data)
# Part 2.9: Check if expression set is normally distributed
p.vals <- rbind(
apply(data, 1, function(x) shapiro.test(as.matrix(x))$p.value),
apply(data, 1, function(x) kruskal.test(as.numeric(x) ~ as.factor(x))$p.value)
)
p.vals <- as.data.frame(p.vals)
row.names(p.vals) <- c("Normality: Shapiro-Wilk", "Population Equality: Kruskal-Wallis")
print(p.vals[1:10])
# Part 2.11: Check the normality of gene expressions per patient
# Part 2.11.1: Pick 5000 features; 5000 is the limit for shapiro.test()
testgenes.patient <- data[sample(rownames(data), 5000), ]
# Part 2.11.2: Perform tests on the column (patient)
p.vals.patient <- rbind(
apply(testgenes.patient, 2, function(x) shapiro.test(as.matrix(x))$p.value),
apply(testgenes.patient, 2, function(x) kruskal.test(as.numeric(x) ~ as.factor(x))$p.value)
)
row.names(p.vals.patient) <- c("Normality: Shapiro-Wilk", "Population Equality: Kruskal-Wallis")
p.vals.patient <- as.data.frame(p.vals.patient)
# Part 2.11.3: Check which of the patients have non-normal distribution of gene expressions
# Ho: The gene expressions are normally distributed.
# Ha: The gene expressions are not normally distributed.
print(colnames(p.vals.patient[1, which(p.vals.patient[1, ] < alpha)]))
# "In case the gene expression values over the patients are non-normally distributed one may want
# to subtract the median and divide by the MAD." (Krijnen)
data.pp <- data1 <- e[, colnames(p.vals.patient[1, which(p.vals.patient[1, ] < alpha)])]   # Get only those with
mads <- apply(exprs(data1), 2, mad)
meds <- apply(exprs(data1), 2, median)
dat <- sweep(exprs(data1), 2, meds)
exprs(data.pp) <- sweep(dat, 2, mads, FUN="/")
boxplot(exprs(data.pp))
# Remove rawData variable to save space
rm(rawData, celFiles, data1)
# Part 3: Data Preparation
# Part 3.1: Gene Filtering
# Part 3.1.1: Coefficient of Variation (cv)
# cv = 1 - standard deviation equals the mean, so that the experimental effect is small relative to the precision of measurement. If,
# cv < 0.2 - the mean is Â¯ve times larger than the standard deviation, so that both the experimental effect and the measurement precision are large.
cvval <- apply(exprs(data.pp), 1, function(x){sd(x)/abs(mean(x))})
features.gf.1 <- rownames(data[cvval < 0.2, ])
remove(cvval)
# Part 3.1.2: Normality and T-test
f1 <- function(x) (shapiro.test(x)$p.value > alpha)
f2 <- function(x) (t.test(x ~ diagnosis.binom.fact)$p.value < alpha)    # Ha - True differences between group means is zero
sel1 <- genefilter(exprs(e)[, which(diagnosis.fact != 9)], filterfun(f1))   # Select diagnosed patients
sel2 <- genefilter(exprs(e)[, which(diagnosis.fact == 9)], filterfun(f1))   # Select control patients
sel3 <- genefilter(exprs(e), filterfun(f2))
selected <- sel1 & sel2 & sel3
features.gf.2 <- rownames(data[selected, ])
remove(f1, f2, sel1, sel2, sel3, selected)
# Part 3.1.3: ANOVA
# Get all with diagnosis
diagnosis.fact.named <- diagnosis
diagnosis.fact.named[which(diagnosis.fact.named == 1)] <- "BPD"
diagnosis.fact.named[which(diagnosis.fact.named == 2)] <- "MDD"
diagnosis.fact.named[which(diagnosis.fact.named == 3)] <- "SCZ"
diagnosis.fact.named[which(diagnosis.fact.named == 9)] <- "CTL"
data.pp.diagnosed <- data.pp[, which(diagnosis.fact.named != "CTL")]
panova <- apply(exprs(data.pp), 1, function(x) anova(lm(x ~ diagnosis.fact))$Pr[1])
features.gf.3 <- featureNames(data.pp)[panova < alpha]
remove(panova, data.pp.diagnosed)
# Part 3.1.4: Combine similar features
features.gf <- Reduce(intersect, List(features.gf.1, features.gf.2, features.gf.3))
# Part 3.1.5: Create a correlation matrix across each features
features.gf.corr <- rcorr(as.matrix(t(exprs(data.pp)[features.gf, ])))
corrplot(features.gf.corr$r)
# Part 3.2: Principal Component Analysis
# Step 3.2.1: Check for null values (If it returned more than 0, there is a null value)
print(colSums(is.na(exprs(data.pp)))[colSums(is.na(exprs(data.pp))) != 0])
# Step 3.2.3: Perform PCA
model.pca <- pca(exprs(data.pp), removeVar = 0.1)
# Step 3.2.4: Determine optimum number of PCs
# Step 3.2.4.1: Horn's method
pca.loadings.horn <- parallelPCA(exprs(data.pp))
# Step 3.2.4.2: Find the elbow point
pca.loadings.elbow <- findElbowPoint(model.pca$variance)
# Step 3.2.4.3: Get the PCs with that can explain at least 50% of the variability
print(paste('Number of PCs to consider:'))
print(paste('Horn:', pca.loadings.horn$n, '%Varation:', sum(model.pca$variance[1:pca.loadings.horn$n])))
print(paste('Elbow:', pca.loadings.elbow, '%Variation:', sum(model.pca$variance[1:pca.loadings.elbow])))
pca.loadings.min <- min(pca.loadings.horn$n, pca.loadings.elbow)
# Step 3.2.5: Get the loadings
model.pca.important <- as.data.frame(model.pca$loadings[, 1:pca.loadings.min])
# Step 3.2.6: Export
write.csv(model.pca.important, paste(datadir, "../Export/model.pca.important.csv", sep = ""), row.names = TRUE)
# Step 3.2.7: Visualize PCA
# Step 3.2.7.1: Scree plot to see where to cut the data
screeplot(model.pca,
components = getComponents(model.pca, 1:20),
vline = c(pca.loadings.horn$n, pca.loadings.elbow)) +
geom_label(aes(x = pca.loadings.horn$n + 1, y = 50,
label = 'Horn\'s', vjust = -1, size = 8)) +
geom_label(aes(x = pca.loadings.elbow + 1, y = 50,
label = 'Elbow method', vjust = -1, size = 8))
# Step 3.2.7.2: Pairs plot to compare one PC against another across all 5 PCs.
pairsplot(model.pca)
# Step 3.2.7.3: Biplot
biplot(model.pca, showLoadings = TRUE, labSize = 5, pointSize = 5, sizeLoadingsNames = 5)
# Step 3.2.7.4: Top 1%
plotloadings(model.pca,
rangeRetain = 0.01,
labSize = 4.0,
title = 'Loadings plot',
subtitle = 'PC1, PC2, PC3, PC4, PC5',
caption = 'Top 1% variables',
shape = 24,
col = c('limegreen', 'black', 'red3'),
drawConnectors = TRUE)
# Step 3.2.7.5: Top 10%
plotloadings(model.pca,
components = getComponents(model.pca, 1:pca.loadings.min),
rangeRetain = 0.1,
labSize = 4.0,
absolute = FALSE,
title = 'Loadings plot',
subtitle = 'Misc PCs',
caption = 'Top 10% variables',
shape = 23, shapeSizeRange = c(1, 16),
col = c('white', 'pink'),
drawConnectors = FALSE)
# Step 3.2.7.5: Top 10%
model.pca.vars <- plotloadings(model.pca,
components = getComponents(model.pca, 1:pca.loadings.min),
rangeRetain = 0.1,
labSize = 4.0,
absolute = FALSE,
title = 'Loadings plot',
subtitle = 'Misc PCs',
caption = 'Top 10% variables',
shape = 23, shapeSizeRange = c(1, 16),
col = c('white', 'pink'),
drawConnectors = FALSE)
model.pca.vars$layers
model.pca.vars$facet
View(model.pca.vars)
View(model.pca.vars)
save.image("E:/jmcco/OneDrive - University of the Philippines/School/AY 2022-2023/2nd Sem/HI 299 Research Methods in Health Informatics/HI 299 Project/DLPFC-Gene-Expression/Multinomial/.RData")
# Step 3.2.8: Transform to prcomp
#model.pca.prcomp <- BiocSingular::runPCA(t(exprs(e)), rank = pca.loadings.min, scale = TRUE)
model.pca.prcomp <- list(sdev = model.pca$sdev,
rotation = data.matrix(model.pca$loadings),
x = data.matrix(model.pca$rotated),
center = TRUE, scale = TRUE
)
class(model.pca.prcomp) <- 'prcomp'
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
# Step 3.2.9.3: Biplot of individuals and variables
fviz_pca_biplot(model.pca.prcomp, repel = TRUE,
col.var = "#2E9FDF", # Variables color
col.ind = "#696969"  # Individuals color
)
get_pca_var(model.pca.prcomp)
View(model.pca.vars)
library(Biobase, lib.loc = package_loc); library(BiocSingular, lib.loc = package_loc); library(tzdb, lib.loc = package_loc); library(vroom, lib.loc = package_loc); library(readr, lib.loc = package_loc)
library(S4Vectors, lib.loc = package_loc); library(IRanges, lib.loc = package_loc); library(XVector, lib.loc = package_loc); library(GenomeInfoDb, lib.loc = package_loc); library(Biostrings, lib.loc = package_loc)
library(backports, lib.loc = package_loc); library(ggcorrplot, lib.loc = package_loc)
library(BiocGenerics, lib.loc = package_loc)
library(oligoClasses, lib.loc = package_loc); library(memoise, lib.loc = package_loc); library(pd.huex.1.0.st.v2, lib.loc = package_loc); library(oligo, lib.loc = package_loc, attach.required = TRUE)
# Part 2: Exploration
library(ggpubr, lib = package_loc); library(genefilter, lib = package_loc); library(limma, lib = package_loc)
library(multtest, lib = package_loc); library(annaffy, lib = package_loc); library(hgu95av2.db, lib = package_loc)
# Part 3: Dimension Reduction
library(locfit, lib.loc = package_loc)
library(corrr, lib.loc = package_loc); library(idm, lib.loc = package_loc); library(irlba, lib.loc = package_loc)
library(PCAtools, lib.loc = package_loc); library(RMTstat, lib.loc = package_loc); library(biomaRt, lib.loc = package_loc); library(cowplot, lib.loc = package_loc); library(ggplotify, lib.loc = package_loc)
library(nnet, lib.loc = package_loc)
library(randomForest, lib.loc = package_loc)
help(fviz_pca_var)
??fviz_pca_var
# Results for Variables
models.pca.vars.2 <- get_pca_var(model.pca.prcomp)
library(corrplot, lib.loc = package_loc); library(factoextra, lib.loc = package_loc)
# Results for Variables
models.pca.vars.2 <- get_pca_var(model.pca.prcomp)
print(model.pca.vars.2$contrib)  # Contribution of the variable to the PCs
View(models.pca.vars.2)
# Results for Variables
model.pca.vars.2 <- get_pca_var(model.pca.prcomp)
print(models.pca.ind$contrib)  # Contribution of the variable to the PCs
remove(models.pca.vars.2)
print(model.pca.vars.2$contrib)  # Contribution of the variable to the PCs
View(model.pca.vars.2$contrib)  # Contribution of the variable to the PCs
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE,     # Avoid text overlapping
label="none",
habillage=diagnosis,
addEllipses=TRUE,
ellipse.level=0.95
)
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE,     # Avoid text overlapping
label="none",
habillage=diagnosis.fact,
addEllipses=TRUE,
ellipse.level=0.95
)
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE,     # Avoid text overlapping
label="none",
habillage=diagnosis.fact.named,
addEllipses=TRUE,
ellipse.level=0.95
)
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
label="none",
habillage=diagnosis.fact.named,
addEllipses=TRUE,
ellipse.level=0.95
)
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
label="ind",
habillage=diagnosis.fact.named,
addEllipses=TRUE,
ellipse.level=0.95
)
# Step 3.2.9: Visualization of PCs
# Step 3.2.9.1: Graph of individuals. Individuals with a similar profile are grouped together.
fviz_pca_ind(model.pca.prcomp,
label="ind",
habillage=diagnosis.fact.named,
addEllipses=TRUE,
ellipse.level=0.95,
repel = TRUE
)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
label="none",
habillage=diagnosis.fact.named,
addEllipses=TRUE,
ellipse.level=0.95,
repel = TRUE
)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
label="none",
addEllipses=TRUE,
ellipse.level=0.95,
repel = TRUE
)
# Step 3.2.9.3: Biplot of individuals and variables
fviz_pca_biplot(model.pca.prcomp, repel = TRUE,
col.var = "#2E9FDF", # Variables color
col.ind = "#696969"  # Individuals color
)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp, col.var="steelblue")+
theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
col.var="steelblue")+
theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib")+
theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF"
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF"
) + theme_minimal()
View(model.pca.vars.2$contrib)  # Contribution of the variable to the PCs
order(model.pca.vars.2$contrib)
order(model.pca.vars.2$contrib, decreasing = TRUE)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(cos2 = 0.95, contrib = intval(nrow(data.pp) * 0.1)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(cos2 = 0.95, contrib = integer(nrow(data.pp) * 0.1)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = integer(nrow(data.pp) * 0.1)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = 5),
) + theme_minimal()
integer(nrow(data.pp) * 0.1)
nrow(data.pp)
nrow(data.pp) * 0.1
integer(nrow(data.pp) * 0.1)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = round(nrow(data.pp) * 0.1)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = 1000),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = 500),
) + theme_minimal()
nrow(data.pp) * 0.01
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
geom = c("point", "text"),
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "#2E9FDF",
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "#2E9FDF",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "#red3",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "red3",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
a <- fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "red3",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
a
View(a)
View(a)
a$data
remove(a)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
model.pca.vars.2 <- fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "red3",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
model.pca.vars.2 <- model.pca.vars.2$data[, 1:round(nrow(data.pp) * 0.01)]
model.pca.vars.2$data[, 1:220]
model.pca.vars.2$data
model.pca.vars.2 <- model.pca.vars.2$data[1:round(nrow(data.pp) * 0.01), ]
model.pca.vars.2 <- model.pca.vars.2$data[1:round(nrow(data.pp) * 0.01), 'name']
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
model.pca.vars.2 <- fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "red3",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
model.pca.vars.2 <- model.pca.vars.2$data[1:round(nrow(data.pp) * 0.01), 'name']
model.pca.vars.2
as.list(model.pca.vars.2)
as.character(model.pca.vars.2)
# Step 3.2.9.2: Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
model.pca.vars.2 <- fviz_pca_var(model.pca.prcomp,
alpha.var="contrib",
col.var = "red3",
repel = TRUE,
select.var = list(contrib = round(nrow(data.pp) * 0.01)),
) + theme_minimal()
model.pca.vars.2 <- as.character(model.pca.vars.2$data[1:round(nrow(data.pp) * 0.01), 'name'])
# Step 3.2.9.3: Biplot of individuals and variables
fviz_pca_biplot(model.pca.prcomp, repel = TRUE,
col.var = "#2E9FDF", # Variables color
col.ind = "#696969",  # Individuals color,
select.var = list(contrib = round(nrow(data.pp) * 0.01))
)
model.pca.vars
# Step 3.2.7.5: Top 10%
model.pca.vars.1 <- plotloadings(model.pca,
components = getComponents(model.pca, 1:pca.loadings.min),
rangeRetain = 0.1,
labSize = 4.0,
absolute = FALSE,
title = 'Loadings plot',
subtitle = 'Misc PCs',
caption = 'Top 10% variables',
shape = 23, shapeSizeRange = c(1, 16),
col = c('white', 'pink'),
drawConnectors = FALSE)
remove(model.pca.vars)
View(model.pca.vars.1)
model.pca.vars.1$data$var
model.pca.vars.1 <- model.pca.vars.1$data$var
features.pca.1 <- model.pca.vars.1
features.pca.2 <- model.pca.vars.2
remove(model.pca.vars.1, model.pca.vars.2)
# Step 3.3: Combine the features from Gene Filtering and PCA
features.redux <- Reduce(intersect, List(features.gf.1, features.gf.2, features.gf.3, features.pca.1, features.pca.2))
# Step 3.3: Combine the features from Gene Filtering and PCA
features.redux <- Reduce(intersect, List(features.gf, features.pca.1, features.pca.2))
# Step 3.2.9: For each of the principal component, get the variable with highest magnitude of eigenvalues
features.pca <- Reduce(intersect, List(features.pca.1, features.pca.2))
# Part 3.1.4.1: Put to HTML the names of the features
atab <- aafTableAnn(features.pca, "pd.huex.1.0.st.v2", aaf.handler()[c(1:3,8:9,11:13)])
saveHTML(atab, file=paste(datadir, "Export/PCA Probe Names.html", sep = ""))
# Part 3.1.5: Create a correlation matrix across each features
features.pca.corr <- rcorr(as.matrix(t(exprs(data.pp)[features.pca, ])))
BiocManager::install(
c("rcorr"),
#force = TRUE,
dependencies = TRUE,
lib = package_loc
)
library(corrplot, lib.loc = package_loc); library(factoextra, lib.loc = package_loc); library(rcorr, lib.loc = package_loc)
install.packages(
c("rcorr"),
#force = TRUE,
dependencies = TRUE,
lib = package_loc
)
View(features.gf.corr)
# Part 3.1.5: Create a correlation matrix across each features
features.gf.corr <- rcorr(as.matrix(t(exprs(data.pp)[features.gf, ])))
